# Security Principles and Patterns

---
description: Security requirements and patterns for protecting user data and system integrity
globs: ["**/*"]
alwaysApply: true
---

## Security Philosophy

Security is not a feature - it's a foundation. Every architectural decision must consider security implications. In Alembic, we handle sensitive user data (personal questions, psychological insights) that demands protection.

**Principle**: Defense in depth - multiple layers of protection, never rely on a single control.

## Authentication

### Supabase Auth Configuration

- **Use Supabase Auth exclusively** - don't roll your own auth
- **Enable email confirmation** for new accounts
- **Configure password requirements**: minimum 8 characters, complexity rules
- **Enable MFA option** for users who want it

### JWT Handling

```python
# Always validate JWTs on the backend
from fastapi import Depends, HTTPException
from fastapi.security import HTTPBearer

security = HTTPBearer()

async def get_current_user(token: str = Depends(security)) -> User:
    try:
        payload = supabase.auth.get_user(token.credentials)
        return User(id=payload.user.id, email=payload.user.email)
    except Exception:
        raise HTTPException(status_code=401, detail="Invalid authentication")
```

### Session Management

- **Short-lived access tokens** (default 1 hour)
- **Refresh tokens** for seamless re-authentication
- **Invalidate sessions** on password change
- **Log authentication events** for audit trail

## Authorization

### Row Level Security (RLS)

**Every table must have RLS enabled** with appropriate policies.

```sql
-- Enable RLS on readings table
ALTER TABLE readings ENABLE ROW LEVEL SECURITY;

-- Users can only see their own readings
CREATE POLICY "Users view own readings"
ON readings FOR SELECT
USING (auth.uid() = user_id);

-- Users can only insert their own readings
CREATE POLICY "Users create own readings"
ON readings FOR INSERT
WITH CHECK (auth.uid() = user_id);

-- Users can only delete their own readings
CREATE POLICY "Users delete own readings"
ON readings FOR DELETE
USING (auth.uid() = user_id);
```

### Authorization Checks

```python
# Always verify ownership before operations
async def get_reading(reading_id: str, user: User = Depends(get_current_user)):
    reading = await db.get_reading(reading_id)
    if reading.user_id != user.id:
        raise HTTPException(status_code=403, detail="Not authorized")
    return reading
```

## API Security

### Input Validation

**Never trust user input.** Validate everything.

```python
from pydantic import BaseModel, Field, validator

class ReadingRequest(BaseModel):
    question: str = Field(..., min_length=1, max_length=1000)
    spread_type: SpreadType
    
    @validator("question")
    def sanitize_question(cls, v):
        # Remove any potential injection attempts
        return v.strip()

# FastAPI validates automatically with Pydantic
@router.post("/reading")
async def create_reading(request: ReadingRequest):  # Auto-validated
    ...
```

### Rate Limiting

```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

@router.post("/reading")
@limiter.limit("10/minute")  # Max 10 readings per minute
async def create_reading(request: Request, ...):
    ...

@router.post("/auth/login")
@limiter.limit("5/minute")  # Strict limit on auth endpoints
async def login(request: Request, ...):
    ...
```

### CORS Configuration

```python
from fastapi.middleware.cors import CORSMiddleware

# Explicit origins only - never use "*" in production
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://alembic.app",
        "https://www.alembic.app",
    ],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["Authorization", "Content-Type"],
)
```

### Security Headers

```python
from fastapi import FastAPI
from starlette.middleware.base import BaseHTTPMiddleware

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Strict-Transport-Security"] = "max-age=31536000"
        response.headers["Content-Security-Policy"] = "default-src 'self'"
        return response
```

## Secrets Management

### Environment Variables

```bash
# .env.example - document required secrets
SUPABASE_URL=https://xxx.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_KEY=your-service-key  # Server-side only!
XAI_API_KEY=xai-xxx
STRIPE_SECRET_KEY=sk_xxx
STRIPE_WEBHOOK_SECRET=whsec_xxx
```

### Never Commit Secrets

```gitignore
# .gitignore
.env
.env.local
.env.production
*.pem
*.key
```

### Secret Rotation

- **Document rotation procedures** in `docs/guides/secret-rotation.md`
- **Use different keys** for development/staging/production
- **Rotate immediately** if any key is exposed

## Payment Security (Stripe)

### Never Handle Card Data

```typescript
// CORRECT - Use Stripe Elements, card data never touches your server
import { CardElement, useStripe, useElements } from "@stripe/react-stripe-js";

const CheckoutForm = () => {
  const stripe = useStripe();
  const elements = useElements();
  
  const handleSubmit = async () => {
    const { paymentMethod } = await stripe.createPaymentMethod({
      type: "card",
      card: elements.getElement(CardElement),
    });
    // Send paymentMethod.id to your server, NOT card details
  };
};
```

### Webhook Verification

```python
import stripe

@router.post("/webhook/stripe")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")
    
    try:
        event = stripe.Webhook.construct_event(
            payload, sig_header, settings.STRIPE_WEBHOOK_SECRET
        )
    except ValueError:
        raise HTTPException(400, "Invalid payload")
    except stripe.error.SignatureVerificationError:
        raise HTTPException(400, "Invalid signature")
    
    # Process verified event
    ...
```

## Data Protection

### Sensitive Data Handling

```python
# Never log sensitive data
logger.info(f"Processing reading for user {user.id}")  # Good - just ID
logger.info(f"Question: {question}")  # BAD - logs personal content

# Summarize instead of storing raw content in logs
logger.info(f"Processing reading: {len(question)} chars, spread={spread_type}")
```

### Encryption at Rest

- Supabase encrypts data at rest by default
- Use `pgcrypto` for additional field-level encryption if needed

### Data Retention

```python
# Implement data retention policies
async def cleanup_old_readings():
    """Delete readings older than retention period."""
    cutoff = datetime.now() - timedelta(days=settings.READING_RETENTION_DAYS)
    await db.execute(
        "DELETE FROM readings WHERE created_at < $1 AND user_tier = 'free'",
        cutoff
    )
```

## Error Handling

### Don't Leak Information

```python
# BAD - exposes internal details
except Exception as e:
    raise HTTPException(500, str(e))

# GOOD - generic message, log details
except Exception as e:
    logger.exception("Reading creation failed")
    raise HTTPException(500, "An error occurred processing your request")
```

### Audit Logging

```python
# Log security-relevant events
async def log_security_event(
    event_type: str,
    user_id: str | None,
    details: dict,
    ip_address: str,
):
    await db.insert("security_logs", {
        "event_type": event_type,
        "user_id": user_id,
        "details": details,
        "ip_address": ip_address,
        "timestamp": datetime.utcnow(),
    })

# Usage
await log_security_event("login_success", user.id, {}, request.client.host)
await log_security_event("login_failed", None, {"email": email}, request.client.host)
```

## Security Checklist

Before deploying any feature, verify:

- [ ] Input validation on all user data
- [ ] Authentication required for protected endpoints
- [ ] Authorization checks for resource access
- [ ] Secrets in environment variables only
- [ ] No sensitive data in logs
- [ ] Rate limiting on expensive operations
- [ ] CORS configured for specific origins
- [ ] Error messages don't leak internals

